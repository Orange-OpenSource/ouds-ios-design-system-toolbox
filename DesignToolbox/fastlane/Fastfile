#
# Software Name: Orange Unified Design System
# SPDX-FileCopyrightText: Copyright (c) Orange SA
# SPDX-License-Identifier: MIT
#
# This software is distributed under the MIT license,
# the text of which is available at https://opensource.org/license/MIT/
# or see the "LICENSE" file for more details.
#
# Authors: See CONTRIBUTORS.txt
# Software description: A SwiftUI components library with code examples for Orange Unified Design System
#

require 'net/http'
require 'json'

# App features configuration
# --------------------------

# TODO Add URL for MoreApps module to get feed from APPS_PLUS backend (cf github.com/Orange-OpenSource/ods-ios)

# Apple configuration
# -------------------

# TestFlight
# Configuration for App Store Connect API (https://appstoreconnect.apple.com/access/integrations/api)
#   OUDS_APPLE_ISSUER_ID = issuer identifier (unique to group)
#   OUDS_APPLE_KEY_ID = key identifier (for the app)
#   OUDS_APPLE_KEY_CONTENT = private key associated to the key identifier
APPLE_ISSUER_ID = ENV["OUDS_APPLE_ISSUER_ID"]
APPLE_KEY_ID = ENV["OUDS_APPLE_KEY_ID"]
APPLE_KEY_CONTENT = ENV["OUDS_APPLE_KEY_CONTENT"]

# Bundle identifier of the app
DEVELOPER_APP_IDENTIFIER = ENV["OUDS_DEVELOPER_BUNDLE_IDENTIFIER"]

# URL for internal portal to upload to App Store
UPLOAD_STORE_URL = ENV["OUDS_UPLOAD_STORE_URL"]

# Notifications and hooks
# -----------------------

MATTERMOST_HOOK_URL = ENV["OUDS_MATTERMOST_HOOK_URL"]
MATTERMOST_HOOK_BOT_NAME = ENV["OUDS_MATTERMOST_HOOK_BOT_NAME"]
MATTERMOST_HOOK_BOT_ICON_URL = ENV["OUDS_MATTERMOST_HOOK_BOT_ICON_URL"]

# GitHub
# ------

# Repository of OUDS iOS library
GITHUB_ORG_LIB_REPO = "Orange-OpenSource/ouds-ios"

# Repository of OUDS iOS Design System Toolbox app
GITHUB_ORG_APP_REPO = "Orange-OpenSource/ouds-ios-design-system-toolbox"

# Fine grained personal access token with enough permissions for the suitable GitHub projects
# Must be configured for both GITHUB_ORG_LIB_REPO and GITHUB_ORG_APP_REPO
GITHUB_ACCESS_TOKEN = ENV['GITHUB_ACCESS_TOKEN']

# Project configuration
# ---------------------

OUDS_WORKSPACE = "DesignToolbox.xcworkspace"
OUDS_PROJECT = "DesignToolbox.xcodeproj"
OUDS_SCHEME = "DesignToolbox"
OUDS_SNAPSHOTS_SNAPSHOTS_TEST_SCHEME = "DesignToolboxSnapshotsTests"
OUDS_SNAPSHOTS_UI_TEST_SCHEME = "DesignToolboxUITests"
OUDS_SNAPSHOTS_UNIT_TEST_SCHEME = "DesignToolboxUnitTests"
OUDS_PROJECT_NAME = "DesignToolbox" # Root for Info.plist, etc.
OUDS_APP_DISPLAY_NAME = "Design System Toolbox"
OUDS_PACKAGE_RESOLVED_PATH = "#{OUDS_WORKSPACE}/xcshareddata/swiftpm/Package.resolved"

module BuildType
    ALPHA = :alpha
    BETA = :beta
    STABLE = :stable
end

# Devices configuration
# ---------------------

OUDS_TEST_DEVICE = "iPhone 16 Pro (18.4)"

# Lanes
# ------

default_platform(:ios)

platform :ios do

    before_all do |lane, options|
        xcodes(
            version: '16.4',
            select_for_current_build_only: true,
        )
    end

    # ------------------------------------------------------------
    # RUN PERIPHERY FOR DEAD CODE ANALYSIS
    # ------------------------------------------------------------
    desc "Run Periphery to look for dead code in the code base. Avoid strict mode because some false positive remains and command must be fine-tuned."
    lane :check_dead_code do
        puts "üëâ Check dead code with Periphery"

        sh "periphery scan --project ../#{OUDS_WORKSPACE} --schemes #{OUDS_SCHEME} --format xcode"
    end

    # ------------------------------------------------------------
    # RUN SWIFT FORMAT TO FORMAT SOURCES
    # ------------------------------------------------------------
    desc "Run SwiftFormat to format Swift source files according to the local configuration and apply source header template."
    lane :format do
        puts "üëâ Run Swift Format to format sources"

        template = '\\nSoftware Name: OUDS iOS\\nSPDX-FileCopyrightText: Copyright (c) Orange SA\\nSPDX-License-Identifier: MIT\\n\\nThis software is distributed under the MIT license,\\nthe text of which is available at https://opensource.org/license/MIT/\\nor see the \\"LICENSE\\" file for more details.\\n\\nAuthors: See CONTRIBUTORS.txt\\nSoftware description: A SwiftUI components library with code examples for Orange Unified Design System\\n'
        sh "cd .. && swiftformat . --header \"#{template}\""
    end

    # ------------------------------------------------------------
    # RUN SWIFT LINT TO CHECK SMELLS
    # ------------------------------------------------------------
    desc "Run SwiftLint in strict mode to detect code smells using local configuration for app, snapshots, units and UI tests"
    lane :lint do
        puts "üëâ Run Swift Lint for smells"

        # If there are violations, error 2 will be returned by swiftlint, making Fastlane fail (expected)
        sh "cd .. && swiftlint --strict --config ../.swiftlint.yml DesignToolbox/* DesignToolboxSnapshotsTests/* DesignToolboxUITests/* DesignToolboxUnitTests/*"
    end

    # ------------------------------------------------------------
    # RUN LICENSE-PLSIT FOR 3RD PARTIES UPDATES
    # ------------------------------------------------------------
    desc "Run LicensePlist to update list of third-parties to embed in app"
    lane :update_3rd_parties do
        puts "üëâ Run LicensePlist to update list of third-parties"

        Dir.chdir ".." do
            # Run the command to generate assets
            sh "license-plist --add-version-numbers --add-sources --force --suppress-opening-directory"

            # Copy assets and delete temporary folders
            sh "rm -rf Settings.bundle/com.mono0926.LicensePlist &&  mv -f com.mono0926.LicensePlist.Output/com.mono0926.LicensePlist Settings.bundle"
            sh "rm -rf Settings.bundle/com.mono0926.LicensePlist.plist && mv com.mono0926.LicensePlist.Output/com.mono0926.LicensePlist.plist Settings.bundle"
            sh "rm -rf com.mono0926.LicensePlist.Output"
        end
    end

    # ------------------------------------------------------------
    # RUN GITLEAKS FOR SECRET LEAKS SCAN
    # ------------------------------------------------------------
    desc "Run GitLeaks to look for leaks of secrets in project and Git history"
    lane :check_leaks do
        puts "üëâ Run Gitleaks for leaks scan"

        # If there are violations, non 0 error be returned by swiftlint, making Fastlane fail (expected)
        sh "cd .. && gitleaks detect -v -l debug --source ."
    end

    # ------------------------------------------------------------
    # RUN SYFT AND GRYPE TO BUILD AND ANALYSE SBOM
    # ------------------------------------------------------------
    desc "Generates a SBOM (Software Bill Of Materials) in SPDX JSON format with Syft and analyse it with Grype to as to look for vulnerabilities"
    lane :update_sbom do
        puts "üëâ Run Syft to generate the SBOM"

        # Or also cyclonedx-json
        sbomFormat = "spdx-json"

        # In { negligible, low, medium, high, critical }
        vulnerabilitiesTolerance = "negligible"

        Dir.chdir "../.." do
            # Run the command to generate SBOM
            sh "syft . -o #{sbomFormat} > SBOM.json"

            # Process the SBOM
            sh "grype sbom:./SBOM.json --fail-on #{vulnerabilitiesTolerance}"
        end
    end

    # ------------------------------------------------------------
    # UPDATE BUILD NUMBER WITH TIMESTAMP
    # ------------------------------------------------------------
    desc "UPDATE BUILD NUMBER WITH TIMESTAMP"
    lane :update_build_number do
        puts "üëâ Update build number"

        timestamp = sh 'date +%s' # Timestamp are unique, incremental and bring details about build date
        timestamp = timestamp.strip!
        puts "‚ÑπÔ∏è New builder number: '#{timestamp}'"

        increment_build_number(xcodeproj: OUDS_PROJECT, build_number: timestamp)
    end

    # TODO Add lane for add_credentials_appsplus (cf github.com/Orange-OpenSource/ods-ios)
    
    # -------------------
    # RUN SNAPSHOTS TESTS
    # -------------------
    desc "Run snapshots tests in the demo app to look for visual regressions of components defined in OUDS package"
    lane :test_snapshots do
        puts "üëâ Run UI tests"

        # Should have on runner one device under at least iOS 15
        # Check the available devices using `xcrun xctrace list devices`
        # Add new environments using `xcodebuild -downloadPlatform iOS`
        begin
            scan(scheme: OUDS_SNAPSHOTS_SNAPSHOTS_TEST_SCHEME,
                device: OUDS_TEST_DEVICE,
                skip_build: true
            )

            if MATTERMOST_HOOK_URL.nil? || MATTERMOST_HOOK_URL.empty?
                puts "‚ÑπÔ∏è No MATTERMOST_HOOK_URL defined, it could mean this lane is called on GitHub Action workflow or locally"
            else
                publish_mattermost_notification("üß™ ‚úÖ No issue with snapshots tests")
            end
        rescue => error
            if MATTERMOST_HOOK_URL.nil? || MATTERMOST_HOOK_URL.empty?
                puts "‚ÑπÔ∏è No MATTERMOST_HOOK_URL defined, it could mean this lane is called on GitHub Action workflow or locally"
            else
                publish_mattermost_notification("üß™ üö® @channel Some issue occured with tests (:test_snapshots)")
            end
            raise error
        end
    end

    # ------------
    # RUN UI TESTS
    # ------------
    desc "Run UI tests in the demo app to check some specific components behaviors"
    lane :test_ui do
        puts "üëâ Run UI tests"

        # Should have on runner one device under at least iOS 15
        # Check the available devices using `xcrun xctrace list devices`
        # Add new environments using `xcodebuild -downloadPlatform iOS`
        begin
            scan(scheme: OUDS_SNAPSHOTS_UI_TEST_SCHEME,
                device: OUDS_TEST_DEVICE,
                skip_build: true
            )

            if MATTERMOST_HOOK_URL.nil? || MATTERMOST_HOOK_URL.empty?
                puts "‚ÑπÔ∏è No MATTERMOST_HOOK_URL defined, it could mean this lane is called on GitHub Action workflow or locally"
            else
                publish_mattermost_notification("üß™ ‚úÖ No issue with UI tests")
            end
        rescue => error
            if MATTERMOST_HOOK_URL.nil? || MATTERMOST_HOOK_URL.empty?
                puts "‚ÑπÔ∏è No MATTERMOST_HOOK_URL defined, it could mean this lane is called on GitHub Action workflow or locally"
            else
                publish_mattermost_notification("üß™ üö® @channel Some issue occured with tests (:test_ui)")
            end
            raise error
        end
    end

    # --------------
    # RUN UNIT TESTS
    # --------------
    desc "Run Unit tests in the demo app to check some specific components behaviors"
    lane :test_unit do
        puts "üëâ Run unit tests"

        # Should have on runner one device under at least iOS 15
        # Check the available devices using `xcrun xctrace list devices`
        # Add new environments using `xcodebuild -downloadPlatform iOS`
        begin
            scan(scheme: OUDS_SNAPSHOTS_UNIT_TEST_SCHEME,
                device: OUDS_TEST_DEVICE,
                skip_build: true
            )

            if MATTERMOST_HOOK_URL.nil? || MATTERMOST_HOOK_URL.empty?
                puts "‚ÑπÔ∏è No MATTERMOST_HOOK_URL defined, it could mean this lane is called on GitHub Action workflow or locally"
            else
                publish_mattermost_notification("üß™ ‚úÖ No issue with unit tests")
            end
        rescue => error
            if MATTERMOST_HOOK_URL.nil? || MATTERMOST_HOOK_URL.empty?
                puts "‚ÑπÔ∏è No MATTERMOST_HOOK_URL defined, it could mean this lane is called on GitHub Action workflow or locally"
            else
                publish_mattermost_notification("üß™ üö® @channel Some issue occured with tests (:test_unit)")
            end
            raise error
        end
    end

    # ------------------------------------------------------------
    # BUILD DEBUG
    # ------------------------------------------------------------
    desc "Build locally the demo app in debug mode without upload"
    lane :build_debug do
        puts "üëâ Build debug app"

        cocoapods(
          clean_install: true
        )

        Dir.chdir "../#{OUDS_PROJECT_NAME}/Resources/Assets.xcassets" do
            sh "rm -Rf AppIconRelease.appiconset"
            sh "cp -R AppIconDebug.appiconset AppIconRelease.appiconset"
        end

        gym(
            scheme: OUDS_SCHEME,
            output_directory: 'build/',
            archive_path: 'build/',
            output_name: 'odsApp',
            configuration: 'Debug',
            include_symbols: true,
            skip_archive: true,
            destination: "generic/platform=iOS Simulator"
        )
    end

    # ------------------------------------------------------------
    # BUILD & UPLOAD TO TESTFLIGHT ALPHA APP
    # ------------------------------------------------------------
    desc "Build the demo app in alpha mode and upload to TestFlight"
    lane :build_alpha do |params|

        issues_numbers = params[:issueNumber]
        puts "üëâ Alpha (commit hash = '#{params[:commitHash]}', issue number = '#{issues_numbers}')"

        if issues_numbers.nil? || issues_numbers.empty?
            puts "‚ùå Error: No issues numbers have been given for alpha builds, nothing will be done"
            publish_mattermost_notification("‚öôÔ∏è üò∞ Tried to build alpha version without mentioning issues numbers!")
            raise "Bad prerequisites error - missing pipeline variable"
        end

        Dir.chdir "../#{OUDS_PROJECT_NAME}/Resources/Assets.xcassets" do
            sh "rm -Rf AppIconRelease.appiconset"
            sh "cp -R AppIconAlpha.appiconset AppIconRelease.appiconset"
        end

        # CFBundleVersion and CFBundleShortVersionString must follow rules with integers and periods, should not change them
        # But still possible to change CFBundleDisplayName
        new_display_name = "#{OUDS_APP_DISPLAY_NAME} ALPHA (#{issues_numbers})"
        puts "‚ÑπÔ∏è New display name version will be: '#{new_display_name}'"
        set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "CFBundleDisplayName", value: new_display_name)

        # Details for the GUI in the app
        set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSBuildType", value: "alpha")
        set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSBuildTag", value: "#{params[:commitHash][0,7]}".strip)
        set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSBuildDetails", value: "#{issues_numbers}")

        sdk_branch = ouds_swift_package_git_branch
        changelog_url = "https://github.com/Orange-OpenSource/ouds-ios/blob/#{sdk_branch}/CHANGELOG.md"
        set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSSDKChangelog", value: "#{changelog_url}")

        begin
            sdk_version = ouds_swift_package_version
            set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSSDKVersion", value: "#{sdk_version}")
        rescue => error
            puts "‚ùå Error: Not possible to get branch and revision or version and revision for OUDS iOS Swift Package in Package.resolved for alpha build"
        end

        build_and_upload(type: BuildType::ALPHA, upload: true, issues: issues_numbers)
    end

    # ------------------------------------------------------------
    # BUILD & UPLOAD TO TESTFLIGHT BETA APP
    # ------------------------------------------------------------
    desc "Build the demo app in beta mode and upload to TestFlight"
    lane :build_beta do |params|
        puts "üëâ Beta (commit hash = '#{params[:commitHash]}')"
        Dir.chdir "../#{OUDS_PROJECT_NAME}/Resources/Assets.xcassets" do
            sh "rm -Rf AppIconRelease.appiconset"
            sh "cp -R AppIconBeta.appiconset AppIconRelease.appiconset"
        end

        new_display_name = "#{OUDS_APP_DISPLAY_NAME} (BETA)"
        puts "‚ÑπÔ∏è New display name version will be: '#{new_display_name}'"
        set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "CFBundleDisplayName", value: new_display_name)

        # Details for the GUI in the app
        set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSBuildType", value: "beta (nightly)")
        set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSBuildTag", value: "#{params[:commitHash][0,7]}".strip)
        set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSSDKChangelog", value: "https://github.com/Orange-OpenSource/ouds-ios/blob/develop/CHANGELOG.md")
        
        begin
            sdk_version = ouds_swift_package_version
            set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSSDKVersion", value: "#{sdk_version}")
        rescue => error
            puts "‚ùå Error: Not possible to get branch and revision or version and revision for OUDS iOS Swift Package in Package.resolved for beta build"
            raise Exception.new "Undefined OUDS SDK package version"
        end

        # Beta app must point to OUDS iOS develop branch
        if check_package_version_for_beta_app
            build_and_upload(type: BuildType::BETA, upload: true, detailSymbol: params[:commitHash])
        else
            puts "‚ùå Error: The beta code base of the app does not point to an OUDS iOS Swfit Package develop branch"
            publish_mattermost_notification("üì¶ üö® @channel The beta code base of the app does not point to an OUDS iOS Swfit Package develop branch (:beta)")
            raise Exception.new "Not suitable OUDS SDK package version"
        end
    end

    # ------------------------------------------------------------
    # BUILD & UPLOAD TO STORE STABLE APP
    # ------------------------------------------------------------
    desc "Build the demo app in stable mode and, if defined, upload to internal portal for App Store publication"
    lane :build_stable do |params|
        puts "üëâ Stable"

        update_build_number

        new_display_name = "#{OUDS_APP_DISPLAY_NAME}"
        puts "‚ÑπÔ∏è New display name version will be: '#{new_display_name}'"
        set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "CFBundleDisplayName", value: new_display_name)

        # Details for the GUI in the app
        set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSBuildType", value: "stable")
        set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSSDKChangelog", value: "https://github.com/Orange-OpenSource/ouds-ios/blob/main/CHANGELOG.md")

        begin
            sdk_version = ouds_swift_package_version
            set_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSSDKVersion", value: "#{sdk_version}")
        rescue => error
            puts "‚ùå Error: Not possible to get branch and revision or version and revision for OUDS iOS Swift Package in Package.resolved for stable build"
            raise Exception.new "Undefined OUDS SDK package version"
        end

        # Stable app must point to OUDS iOS version
        if check_package_version_for_stable_app
            build

            if params[:upload]
                puts "Upload to store requested"
                upload_2_store()
                build_details = extract_issues_numbers_for_stable
                publish_github_notifications_build_details(BuildType::STABLE, build_details)
            else
                puts "Upload to store not requested"
            end
        else
            puts "‚ùå Error: The stable code base of the app does not point to an OUDS iOS Swfit Package version tag"
            publish_mattermost_notification("üì¶ üö® @channel The stable code base of the app does not point to an OUDS iOS Swfit Package version tag (:stable)")
            raise Exception.new "Not suitable OUDS SDK package version"
        end
    end

    # -----------------------------------------------------------------------
    # PRIVATE LANE BUILD & UPLOAD (ALPHA / BETA is set by main lane)
    # -----------------------------------------------------------------------
    desc "Build the demo app in a defined mode and upload if needed to TestFlight or internal portal for App Store publication"
    private_lane :build_and_upload do |params|
        isAlpha = params[:type] == BuildType::ALPHA

        if isAlpha # Alpha case, detailSymbol should be the issue number of the feature/fix to test
            puts "üëâ Build and upload (alpha)"
            update_build_number
            build
            upload_2_testflight(type: BuildType::ALPHA, issues_numbers: params[:issues])
            publish_github_notifications_build_details(BuildType::ALPHA, get_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSBuildDetails"))

        else # Beta case (not production too), detailSymbol should be here commit hash
            detailSymbol = params[:detailSymbol]
            puts "üëâ Build and upload (type = #{params[:type]}), detail symbol = #{detailSymbol})"
            
            # If already built, prevents to build again for nothing
            # Warning: tag is done before build and not removed, so if build failed, tag will remain and needs to be removed manualy.
            # It prevents to have loops of failing builds.
            if tag_ci_build(detailSymbol)
                # Ensure this build-then-uploaded app has a new and unique build number matching also to code version
                update_build_number
                build
            else
                puts "‚ÑπÔ∏è Nothing new to build today, a CI tag for commit '#{detailSymbol}' already exists"
                publish_mattermost_notification("‚öôÔ∏è ü§î Nothing new to build today, a CI tag for commit '#{detailSymbol}' already exists")
            end
            
            if params[:upload]
                puts "‚ÑπÔ∏è Upload to TestFlight requested"
                # If already uploaded, prevents to upload again
                if tag_testflight_upload(detailSymbol)
                    upload_2_testflight(type: BuildType::BETA)
                    build_details = extract_issues_numbers_for_beta
                    publish_github_notifications_build_details(BuildType::BETA, build_details)
                else
                    puts "‚ÑπÔ∏è Nothing new to build today, a TestFlight tag for commit '#{detailSymbol}' already exists"
                    publish_mattermost_notification("‚öôÔ∏è ü§î Nothing new to build today, a TestFlight tag for commit '#{detailSymbol}' already exists")
                end
            else
                puts "‚ÑπÔ∏è Upload to TestFlight not requested"
            end
        end
    end

    # -----------------------------------------------------------------------
    # PRIVATE LANE BUILD (ALPHA / BETA / STABLE is set by main lane)
    # -----------------------------------------------------------------------
    desc "Build the demo app"
    private_lane :build do
        puts "üëâ Build"

        begin
            update_app_identifier(
                xcodeproj: "#{OUDS_PROJECT}",
                plist_path: "#{OUDS_PROJECT_NAME}/Info.plist",
                app_identifier: CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
            )

            cocoapods(
                clean_install: true
            )

            # Disable automatic code signing for release / distribution builds.
            # Thus we won't use any Xcode with plugged account in, and use only needed certificates and provisioning profiles.
            # Mobile provisioning profile named "OUDS demo app (release)" must be placed in runner.
            # The certificate(s) used to build (with bundle ID) the provisionning profile must be available in the keychain of the runner
            # (both .cer and .p12), here a distribution certificate.
            # This way is more agile and allows to use VM-based solution with on the fly configuration like with Tart.
            update_code_signing_settings(path: "#{OUDS_PROJECT}",
                use_automatic_signing: false,
                profile_name: 'OUDS demo app (release)',
                targets: OUDS_SCHEME)
            
            gym(workspace: "#{OUDS_WORKSPACE}",
                scheme: OUDS_SCHEME,
                configuration: "Release",
                output_directory: "build/",
                export_method: "app-store",
                archive_path: "build/oudsApp.xcarchive",
                xcargs: "-allowProvisioningUpdates")
            
            # Build a ZIP archive to put as artifact to the GitLab CI runner
            # Needed for upload later as .xcarchive for App Store through corporate portal
            zip(path: "build/oudsApp.xcarchive",
                output_path: "build/oudsApp.zip")
                          
            version = get_app_version
            build_number = get_build_number(xcodeproj: OUDS_PROJECT)

            publish_mattermost_notification("üî® ‚úÖ A new build has been done successfully (version = '#{version}', build number = '#{build_number}')")
        rescue => error
            publish_mattermost_notification("üî® üö® @channel Some issue occurred during the build step (:build)")
            raise error
        end
    end

    # --------------------------------------------------------------------------
    # PRIVATE LANE UPLOAD TO TESTFLIGHT (ALPHA / BETA is set by main lane)
    # ---------------------------------------------------------------------------
    desc "Upload the demo app to TestFlight"
    private_lane :upload_2_testflight do |params|
        puts "üëâ Upload"

        begin
            api_key = app_store_connect_api_key(
                key_id: APPLE_KEY_ID,
                issuer_id: APPLE_ISSUER_ID,
                key_content: APPLE_KEY_CONTENT,
                duration: 500,
                in_house: false
            )
            
            TESTFLIGHT_GROUPS = ENV['TESTFLIGHT_GROUPS'] # Defined in Appfile
            
            version = get_app_version
            puts "‚ÑπÔ∏è App version: '#{version}'"

            build_number = get_build_number(xcodeproj: OUDS_PROJECT)
            puts "‚ÑπÔ∏è App build number: '#{build_number}'"

            uploadType = params[:type]
            if uploadType != nil
                issues_numbers = params[:issues_numbers]
                puts "‚ÑπÔ∏è Upload type: '#{uploadType}'"
                if uploadType == BuildType::ALPHA
                    news = "‚ö†Ô∏è Warning: this is alpha build for issues '#{issues_numbers}'\n\n" + read_current_release_notes # Add details about build type in changelog for TestFlight
                else
                    news = "This is a beta build\n\n" + read_current_release_notes # Add details about build type in changelog for TestFlight, beta build here ebcause not alpha and stable are not in TestFlight
                end
            end

            upload_to_testflight(
                changelog: news,
                app_identifier: "#{DEVELOPER_APP_IDENTIFIER}",
                skip_submission: false,
                skip_waiting_for_build_processing: false,
                distribute_external: true,
                notify_external_testers: true,
                groups: TESTFLIGHT_GROUPS,
                api_key: api_key
            )
            
            publish_mattermost_notification("üì¶ ‚úÖ @here The upload to TestFlight has been done successfully (version = '#{version}', build number = '#{build_number}')")    
        rescue => error
            publish_mattermost_notification("üì¶ üö® @channel Some issue occurred during the upload step (:upload)")
            raise error
        end
    end

    # ----------------------------
    # PRIVATE LANE UPLOAD TO STORE
    # ----------------------------
    desc "Upload the demo app to the internal portal for the App Store publication"
    private_lane :upload_2_store do |params|
        puts "üëâ Upload to store"

        begin
            version = get_app_version
            puts "‚ÑπÔ∏è App version: '#{version}'"

            build_number = get_build_number(xcodeproj: OUDS_PROJECT)
            puts "‚ÑπÔ∏è App build number: '#{build_number}'"

            # Escape spaces for upload
            ipa_new_name = "Design_System_Toolbox-#{build_number}.ipa"
            sh "cp ../build/Design\\ System\\ Toolbox.ipa ../build/#{ipa_new_name}"
            sh "curl -F 'file=@../build/#{ipa_new_name}' #{UPLOAD_STORE_URL}"

            publish_mattermost_notification("üì¶ ‚úÖ @here The upload to store has been done successfully (version = '#{version}', build number = '#{build_number}')")
        rescue => error
            publish_mattermost_notification("üì¶ üö® @channel Some issue occurred during the upload step (:upload_2_store)")
            raise error
        end
    end

    # -------
    # Helpers
    # -------

    # Checks if beta build of the design system toolbox app points to develop branch of Swift Package,
    # i.e. points to a branch
    def check_package_version_for_beta_app()
        puts "üëâ Check package version for OUDS iOS Swift package (beta)"
    
        package_resolved_content = File.read("../#{OUDS_PACKAGE_RESOLVED_PATH}")
        package_resolved_json_content = JSON.parse(package_resolved_content)
        ouds_ios_obj = package_resolved_json_content['pins'].find { |pin| pin["identity"] == "ouds-ios" }
        
        return ouds_ios_obj.dig("state", "branch") == "develop"

    end

    # Checks if the current version of the OUDS Swift Package is the expected one for stable builds of the app;
    # i.e. points to a tag
    def check_package_version_for_stable_app()
        puts "üëâ Check package version for OUDS iOS Swift package (stable)"

        package_resolved_content = File.read("../#{OUDS_PACKAGE_RESOLVED_PATH}")
        package_resolved_json_content = JSON.parse(package_resolved_content)
        ouds_ios_obj = package_resolved_json_content['pins'].find { |pin| pin["identity"] == "ouds-ios" }
        
        return !ouds_ios_obj.dig("state", "version").nil?
    end

    # Extract from Package.resolved details about the version in use of the OUDS iOS Swift Package.
    # Returns a string with branch and revision on 8 digits or tag and revision on 8 digits
    def ouds_swift_package_version()
        puts "üëâ Extract version of OUDS iOS Swift package"

        package_resolved_content = File.read("../#{OUDS_PACKAGE_RESOLVED_PATH}")
        package_resolved_json_content = JSON.parse(package_resolved_content)
        ouds_ios_obj = package_resolved_json_content['pins'].find { |pin| pin["identity"] == "ouds-ios" }
        ouds_ios_branch = ouds_ios_obj.dig("state", "branch") # Git branch
        ouds_ios_revision = ouds_ios_obj.dig("state", "revision") # Commit hash
        ouds_ios_version = ouds_ios_obj.dig("state", "version") # Git tag

        if ouds_ios_branch && ouds_ios_revision
            return "#{ouds_ios_branch} (#{ouds_ios_revision[0,7]})"
        elsif ouds_ios_revision && ouds_ios_version
            return "#{ouds_ios_version} (#{ouds_ios_revision[0,7]})"
        else
            raise error
        end
    end

    # Extract from Package.resolved details about the Git branch in use for the OUDS iOS Swift Package.
    # Returns the branch if defined or raises an error.
    # Supposes the OUDS iOS package is defined and used; if a local reference is used instead the branch won't be retrieved
    def ouds_swift_package_git_branch()
        puts "üëâ Extract Git branch of OUDS iOS Swift package"

        package_resolved_content = File.read("../#{OUDS_PACKAGE_RESOLVED_PATH}")
        package_resolved_json_content = JSON.parse(package_resolved_content)
        ouds_ios_obj = package_resolved_json_content['pins'].find { |pin| pin["identity"] == "ouds-ios" }
        ouds_ios_branch = ouds_ios_obj.dig("state", "branch")

        if ouds_ios_branch
            return "#{ouds_ios_branch}"
        else
            raise error
        end
    end

    # Add a Git tag dedicated to CI/CD builds with for some commit hash used to compute tag suffix
    def tag_ci_build(commitHash)
        puts "üëâ Tag CI build"

        begin
            if commitHash.nil? || commitHash.empty?
                puts "‚ÑπÔ∏è No parameter sent for CI tag, nothing will be done"
                publish_mattermost_notification("‚öôÔ∏è ü§î No commit hash has been given, no tag can be created")
                return false
            else
                if create_tag("ci", commitHash)
                    publish_mattermost_notification("üì¶ ‚úÖ  New Git CI tag created for commit #{commitHash}")
                    return true
                else
                    return false
                end
            end
        rescue => error
            publish_mattermost_notification("üì¶ üö® @channel Some issue occurred during the tagging step (:tag_ci_build)")
            raise error
        end
    end

    # Add a Git tag dedicated to TestFLight uploads for some commit hash used to compute tag suffix
    def tag_testflight_upload(commitHash)
        puts "üëâ Tag TestFlight upload"

        begin     
            if commitHash.nil? || commitHash.empty?
                puts "‚ÑπÔ∏è No parameter sent for CI tag, nothing will be done"
                publish_mattermost_notification("‚öôÔ∏è ü§î No commit hash has been given, no tag can be created")
                return false
            else
                if create_tag("Test_Flight", commitHash)
                    publish_mattermost_notification("üì¶ ‚úÖ  New Git Test_Flight tag created for commit #{commitHash}")
                    return true
                else
                    return false
                end
            end
        rescue => error
            publish_mattermost_notification("üì¶ üö® @channel Some issue occurred during the tagging step (:tag_testflight_upload)")
            raise error
        end
    end

    # Creates a Git tag at given commit through HTTP protocol to prevent proxy or firewalls to block SSH requests.
    # Not possible also to make repository mirroring because of the current purchased plan of the GitLab instance.
    def create_tag(prefix, commitHash)
      
        # Check personal access token for tag creation
        if GITHUB_ACCESS_TOKEN.nil? || GITHUB_ACCESS_TOKEN.empty?
            puts "‚ùå Error: No GitHub access token defined, cannot create and push tags"
            publish_mattermost_notification("‚öôÔ∏è üò∞ @channel No GitHub access token defined, cannot create and push tags!")
            return false
        else
            # Check if given tag exists yet
            tag = "#{prefix}/" + commitHash[0,7]
            puts "‚ÑπÔ∏è Check if '#{tag}' exists yet"

            uri = URI("https://api.github.com/repos/#{GITHUB_ORG_APP_REPO}/tags")
            http = Net::HTTP.new(uri.host, uri.port)
            http.use_ssl = true
            
            request = Net::HTTP::Get.new(uri.path)
            request['Accept'] = 'application/vnd.github+json'
            request['Authorization'] = "Bearer #{GITHUB_ACCESS_TOKEN}"
            request['X-GitHub-Api-Version'] = '2022-11-28'

            response = http.request(request)
            tags = JSON.parse(response.body)

            # puts tags.inspect # Uncomment for debug

            if tags.any? { |t| t['name'] == tag }
                puts "‚ÑπÔ∏è The tag '#{tag}' still exists, won't create new tag"
                return false
            else
                puts "‚ÑπÔ∏è Commit SHA to tag is '#{commitHash}'"

                uri = URI("https://api.github.com/repos/#{GITHUB_ORG_APP_REPO}/git/refs")
                http = Net::HTTP.new(uri.host, uri.port)
                http.use_ssl = true
                
                request = Net::HTTP::Post.new(uri.path)
                request['Accept'] = 'application/vnd.github+json'
                request['Authorization'] = "Bearer #{GITHUB_ACCESS_TOKEN}"
                request['X-GitHub-Api-Version'] = '2022-11-28'
                request.body = { ref: "refs/tags/#{tag}", sha: commitHash }.to_json
                
                response = http.request(request)
                
                if response.code.to_i == 201
                  puts "‚ÑπÔ∏è Light tag '#{tag}' published in repository"
                  return true
                else
                  puts "‚ùå Error: Failed to publish light tag '#{tag}' (#{response.code.to_i})"
                  return false
                end
            end
        end
    end

    # Get version set in the Xcode project
    def get_app_version
        version = get_version_number(
            xcodeproj: OUDS_PROJECT,
            target: OUDS_SCHEME
        )
        return version
    end

    # Read release note in section associated to the current version
    # If empty, try within the Unreleased section
    def read_current_release_notes
        version = get_app_version

        changelog = read_changelog(
            changelog_path: '../CHANGELOG.md',
            section_identifier: "[#{version}]",
        )

        if changelog == ""
            changelog = read_changelog(
                changelog_path: '../CHANGELOG.md',
                section_identifier: "[Unreleased]",
            )
        end

        puts "‚ÑπÔ∏è Current relase notes = #{changelog}"
        return changelog
    end

    # From the changelog extract the issues numbers so as to prepare notifications for beta builds.
    # Will extract only issues numbers from "Unreleased" section.
    def extract_issues_numbers_for_beta
        changelog = read_changelog(
            changelog_path: '../CHANGELOG.md',
            section_identifier: "[Unreleased]",
        )

        extracted_issues_numbers = changelog.scan(/#(\d+)/).flatten.uniq

        return extracted_issues_numbers.join(', ')
    end

    # From the changelog extract the issues numbers so as to prepare notifications for stabme builds.
    # Will extract only issues numbers from last release section.
    def extract_issues_numbers_for_stable
        version = get_app_version

        changelog = read_changelog(
            changelog_path: '../CHANGELOG.md',
            section_identifier: "[#{version}]",
        )

        extracted_issues_numbers = changelog.scan(/#(\d+)/).flatten.uniq

        return extracted_issues_numbers.join(', ')
    end

    # Sends a message notification through Mattermost hook
    def publish_mattermost_notification(message)
        mattermost(url: MATTERMOST_HOOK_URL,
                  text: "#{message}",
                  username: MATTERMOST_HOOK_BOT_NAME,
                  icon_url: MATTERMOST_HOOK_BOT_ICON_URL
                  )
    end

    # Send comments to the related GitHub issues about a new available build or release.
    # Will find in Info.plist of demo app all the suitable needed details.
    def publish_github_notifications_build_details(build_type, build_details)
        build_version = get_app_version
        build_number = get_build_number(xcodeproj: OUDS_PROJECT)
        build_display_name = get_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "CFBundleDisplayName")
        build_tag = get_info_plist_value(path: "#{Dir.pwd}/../#{OUDS_PROJECT_NAME}/Info.plist", key: "OUDSBuildTag")

        if build_type === BuildType::ALPHA
            comment_title = "**New TestFlight ALPHA upload available**"
            comment_description = "Please, get the new build from *TestFlight* app, or contact the project maintainers (pylapp, ludovic35) to get access and test this issue implementation."
            comment_notified=<<-EOF
<!--
@B3nz01d - Beno√Æt SUZANNE - Product Owner
@pylapp - Pierre-Yves LAPERSONNE - iOS developer, OUDS iOS maintainer
@ludovic35 - Ludovic PINEL - iOS developer, OUDS iOS maintainer
@jerome-regnier - J√©r√¥me R√âGNIER - designer
@pya35 - Pierre-Yves AYOUL - a11y expert
-->
cc @B3nz01d (product owner)
cc @pylapp @ludovic35 (dev team)
cc @jerome-regnier (design team)
cc @pya35 (a11y team)
EOF
            comment_description_build_tag="- Build tag: **#{build_tag}**"
        elsif build_type === BuildType::BETA
            comment_title = "**New TestFlight BETA upload available**"
            comment_description = "Please, get the new build from *TestFlight* app, or contact the project maintainers (pylapp, ludovic35) to get access and test this issue implementation."
            comment_notified = ""
            comment_description_build_tag="- Build tag: **#{build_tag}**"
        else # BuildType::STABLE
            comment_title = "**New release available**"
            comment_description = "Please, get the [new release from GitHub](https://github.com/Orange-OpenSource/ouds-ios-design-system-toolbox/releases/tag/#{build_version}) and wait for App Store update to test it!"
            comment_notified = ""
            comment_description_build_tag=""
        end

        build_issues_numbers = build_details.scan(/\d+/).map(&:to_i)
        
        build_issues_numbers.each do |issue_number|
            uri = URI("https://api.github.com/repos/#{GITHUB_ORG_LIB_REPO}/issues/#{issue_number}")
            response = Net::HTTP.get(uri)
            issue = JSON.parse(response)
        
            if issue['message'] == 'Not Found'
                puts "‚ùå Error: Issue '#{issue_number}' does not exist"
            else
          
                comment_to_upload=<<-EOF
üì£ #{comment_title} üöÄ

#{comment_description}

- Display name: **#{build_display_name}**
- Version: **#{build_version}**
- Build number: **#{build_number}**
#{comment_description_build_tag}

#{comment_notified}
_ü§ñ This is an automated message sent with love thanks to *Fastlane* from our CI/CD pipeline ü§ò_
EOF

                uri = URI("https://api.github.com/repos/#{GITHUB_ORG_LIB_REPO}/issues/#{issue_number}/comments")
                http = Net::HTTP.new(uri.host, uri.port)
                http.use_ssl = true
          
                request = Net::HTTP::Post.new(uri.path)
                request['Authorization'] = "Bearer #{GITHUB_ACCESS_TOKEN}"
                request['Content-Type'] = 'application/json'
                request.body = { body: comment_to_upload }.to_json
          
                response = http.request(request)
          
                if response.code.to_i == 201
                    puts "‚ÑπÔ∏è Comment posted on issue '#{issue_number}'"
                else
                    puts "‚ùå Error: Failed to post comment on issue '#{issue_number}'"
                end
            end
        end
    end
end
